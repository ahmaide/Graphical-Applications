<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW3</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }

    #controls {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 5px;
      background: #222;
    }

    .joint-control {
      margin-bottom: 10px;
      padding: 5px;
      border-left: 3px solid #00ffaa;
    }

    #controls label, #controls input {
      margin-right: 10px;
      margin-bottom: 5px;
      display: inline-block;
    }

    #controls input[type="range"] {
      width: 150px;
      vertical-align: middle;
    }
  </style>
</head>

<body>
  <h2>Robotic Arm - Hierarchical Model</h2>
  <p>Use mouse to drag and rotate the scene. Use arrow keys and w, s keys to move the camera.</p>
  <p>Please Move The Shoulder Joint (Level 2) To See The Changes In The Base Joint (Level 1) Rotation.</p>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
      <canvas id="glcanvas" width="600" height="600"></canvas>

      <div id="controls">
        <div class="joint-control">
            <b>Base Joint (Level 1 Movement)</b>
            <label for="joint1-slider">Y-Rotation:</label>
            <input type="range" id="joint1-slider" data-joint-id="joint1" min="-180" max="180" value="0">
        </div>
        <div class="joint-control">
            <b>Shoulder Joint (Level 2 Movement)</b>
            <label for="joint2-slider">X-Rotation:</label>
            <input type="range" id="joint2-slider" data-joint-id="joint2" min="-15" max="15" value="0">
        </div>
        <div class="joint-control">
            <b>Wrist Joint (Level 3 Movement)</b>
            <label for="joint3-slider">Y-Rotation:</label>
            <input type="range" id="joint3-slider" data-joint-id="joint3" min="-90" max="90" value="0">
        </div>
        
      </div>
      
    </div>
  </div>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;
uniform float uTime;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;

out vec3 vColor;

void main() {
  gl_Position = uProjectionMatrix * uModelViewMatrix * uModelTransformationMatrix * vec4(aPosition,1.0);
  vColor = aColor;
}

</script>
<!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
in vec3 vColor;
uniform int uObjectIndex;
uniform float uTime;
out vec4 fragColor;

void main() {
  vec3 color_base = vec3(0.6, 0.6, 0.6);
  vec3 color_arm = vec3(1.0, 0.4, 0.0);
  vec3 color_joint = vec3(0.0, 0.4, 1.0);
  vec3 color_end = vec3(0.8, 1.0, 0.0);
  vec3 color_orbit = vec3(8.0, 0.0, 0.6);
  vec3 baseColor;
  
  if (uObjectIndex == 0) {
    baseColor = color_base; 
  } else if (uObjectIndex == 1 || uObjectIndex == 3) {
    baseColor = color_joint;
  } else if (uObjectIndex == 2) { 
    baseColor = color_arm;
  } else if (uObjectIndex == 4) { 
    baseColor = color_arm;
  } else if (uObjectIndex == 5) { 
    baseColor = color_end;
  } else if (uObjectIndex == 6) { 
    baseColor = color_end;
  } else if (uObjectIndex == 7) { 
    baseColor = color_orbit;
  } else {
    baseColor = vec3(1.0, 0.0, 1.0);
  }
  vec3 col = mix(vColor, baseColor, 0.9); 
  fragColor = vec4(col, 1.0);
}
</script>

  <script src="primitives.js"></script>
  <script src="transformations.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader Compile Error:", gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      if (!vs || !fs) return null;
      
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error("Program Link Error:", gl.getProgramInfoLog(prog));
        return null;
      }
      return prog;
    }

    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) console.error("WebGL2 not supported");

    let vertEditor = document.getElementById("vertEditor");
    let fragEditor = document.getElementById("fragEditor"); 
    vertEditor.value = document.getElementById("vertex-shader").textContent;
    fragEditor.value = document.getElementById("fragment-shader").textContent;

    let program, posLoc, colorLoc, uMVM, uPM, uMTM, timeLoc, uObjectIndexLoc; 

    function initShaderProgram() {
      try {
        program = createProgram(gl, vertEditor.value, fragEditor.value); 
        if (!program) return;
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");
        uObjectIndexLoc = gl.getUniformLocation(program, "uObjectIndex");
      } catch (e) { console.error(e); }
    }
    initShaderProgram();
    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;
    
    function createGlObject(gl, positions, colors, indices, baseScale = [1.0, 1.0, 1.0]) {
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const nbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        return {
            vbo, nbo, ibo,
            indexCount: indices.length,
            baseScale: baseScale,
        };
    }
    
    let accumulatedRotationMatrix;
    let proj;
    let startTime; 
    let jointAngles = {
        joint1: 0,
        joint2: 0,
        joint3: 0,
    };

    let mouseDown = false, lastX, lastY;
    let camX = 0, camY = -2, camZ = -20; 

    let sphereData;
    let cylinderData;
    let coneData;

    let rootNode; 
    
    let orbitingBallObj;
    const BALL_SIZE = 0.2;
    const ORBIT_RADIUS = 8.0;
    const ORBIT_SPEED = 0.5;

    
    function drawModel(node, parentMTM) {
        if (!node.object || !node.object.vbo) return;
        
        let LTM = mat4Identity();
        
        LTM = mat4Translate(LTM, node.translation || [0, 0, 0]);

        if (node.rotation) {
            if (node.rotation.axis === 'X') LTM = mat4RotateX(LTM, node.rotation.angle);
            if (node.rotation.axis === 'Y') LTM = mat4RotateY(LTM, node.rotation.angle);
            if (node.rotation.axis === 'Z') LTM = mat4RotateZ(LTM, node.rotation.angle);
        }

        LTM = mat4Scale(LTM, node.object.baseScale);

        const MTM = multiplyMat4(parentMTM, LTM);
        
        gl.uniform1i(uObjectIndexLoc, node.index);
        gl.uniformMatrix4fv(uMTM, false, MTM);

        const obj = node.object;
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.vbo);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, obj.nbo);
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibo);
        gl.drawElements(gl.TRIANGLES, obj.indexCount, gl.UNSIGNED_SHORT, 0);

        if (node.children) {
            node.children.forEach(child => drawModel(child, MTM));
        }
    }


    function render(timestamp) {
        if (!program) return; 

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.1, 0.1, 0.1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const currentTime = (performance.now() - startTime) / 1000.0;

        let modelViewMatrix = mat4Identity();
        modelViewMatrix = mat4Translate(modelViewMatrix, [camX, camY, camZ]);
        
        gl.uniformMatrix4fv(uPM, false, proj);
        gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);
        
        let globalRootMatrix = mat4Identity();
        globalRootMatrix = multiplyMat4(globalRootMatrix, accumulatedRotationMatrix);
        
        drawModel(rootNode, globalRootMatrix);

        if (orbitingBallObj) {
            let ballMTM = mat4Identity();

            ballMTM = mat4Scale(ballMTM, orbitingBallObj.baseScale); 
            
            let translationMatrix = mat4Translate(mat4Identity(), [0.0, 0.0, ORBIT_RADIUS]);
            ballMTM = multiplyMat4(translationMatrix, ballMTM);

            let orbitRotation = mat4RotateY(mat4Identity(), currentTime * ORBIT_SPEED); 
            ballMTM = multiplyMat4(orbitRotation, ballMTM);
            
            ballMTM = multiplyMat4(globalRootMatrix, ballMTM);
            
            gl.uniform1i(uObjectIndexLoc, 7);
            gl.uniformMatrix4fv(uMTM, false, ballMTM);

            const obj = orbitingBallObj;
            gl.bindBuffer(gl.ARRAY_BUFFER, obj.vbo);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, obj.nbo);
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibo);
            gl.drawElements(gl.TRIANGLES, obj.indexCount, gl.UNSIGNED_SHORT, 0);
        }

        requestAnimationFrame(render);
    }

    window.onload = function () {
        
        accumulatedRotationMatrix = mat4Identity(); 
        let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
        proj = perspective(fov, aspect, zNear, zFar);
        
        startTime = performance.now();

        const BASE_HEIGHT = 1.0;
        const SEG_LENGTH = 2.0;
        const SEG_THICKNESS = 0.5;
        const JOINT_RADIUS = 0.8;
        const FINGER_LENGTH = 2.0;
        const FINGER_THICKNESS = 0.3;

        sphereData = generateSphereData(20, 20, 1.0);
        cylinderData = generateCylinderData(24, 1.0, 1.0);
        coneData = generateConeData(24, 1.0, 1.0);

        const baseObj = createGlObject(gl, cylinderData.positions, cylinderData.colors,
         cylinderData.indices, [4.0, BASE_HEIGHT, 4.0]);
        const shoulderJointObj = createGlObject(gl, sphereData.positions, sphereData.colors,
         sphereData.indices, [JOINT_RADIUS, JOINT_RADIUS, JOINT_RADIUS]);
        const lowerArmObj = createGlObject(gl, cylinderData.positions, cylinderData.colors,
         cylinderData.indices, [SEG_THICKNESS, SEG_LENGTH, SEG_THICKNESS]);
        const elbowJointObj = createGlObject(gl, sphereData.positions, sphereData.colors,
         sphereData.indices, [JOINT_RADIUS * 0.8, JOINT_RADIUS * 0.8, JOINT_RADIUS * 0.8]);
        const upperArmObj = createGlObject(gl, cylinderData.positions, cylinderData.colors,
         cylinderData.indices, [SEG_THICKNESS, SEG_LENGTH, SEG_THICKNESS]);
        const finger1Obj = createGlObject(gl, coneData.positions, coneData.colors,
         coneData.indices, [FINGER_THICKNESS, FINGER_LENGTH, FINGER_THICKNESS]);
        const finger2Obj = createGlObject(gl, coneData.positions, coneData.colors,
         coneData.indices, [FINGER_THICKNESS, FINGER_LENGTH, FINGER_THICKNESS]);

        orbitingBallObj = createGlObject(gl, sphereData.positions, sphereData.colors, 
                                         sphereData.indices, [BALL_SIZE, BALL_SIZE, BALL_SIZE]);

        const finger1Node = {
            object: finger1Obj, index: 5,
            translation: [0, FINGER_LENGTH / 2, FINGER_THICKNESS/2], 
            rotation: { axis: 'Z', angle: 0 },
        };
        const finger2Node = {
            object: finger2Obj, index: 6,
            translation: [0, FINGER_LENGTH / 2, -FINGER_THICKNESS/2], 
            rotation: { axis: 'Z', angle: 0 },
        };
        
        const upperArmNode = {
            object: upperArmObj, index: 4,
            translation: [0, SEG_LENGTH / 2, 0], 
            rotation: { axis: 'X', angle: 0 },
            children: [finger1Node, finger2Node]
        };
        const wristJointNode = {
            object: elbowJointObj, index: 3,
            translation: [0, SEG_LENGTH / 2, 0], 
            rotation: { axis: 'Y', angle: 0, jointId: 'joint3' },
            children: [upperArmNode]
        };

        const lowerArmNode = {
            object: lowerArmObj, index: 2,
            translation: [0, SEG_LENGTH / 2, 0], 
            rotation: { axis: 'X', angle: 0, jointId: 'joint2' },
            children: [wristJointNode]
        };
        const shoulderJointNode = {
            object: shoulderJointObj, index: 1,
            translation: [0, BASE_HEIGHT / 2, 0], 
            rotation: { axis: 'Y', angle: 0, jointId: 'joint1' },
            children: [lowerArmNode]
        };
        
        lowerArmNode.rotation.angle = -Math.PI / 2; 
        
        rootNode = {
            object: baseObj, index: 0,
            translation: [0, BASE_HEIGHT/2 - 5.0, 0],
            children: [shoulderJointNode]
        };


        function updateJointAngle(jointId, value) {
            const angle = value * Math.PI / 180; 
            jointAngles[jointId] = angle;
            
            const updateNode = (node) => {
                if (node.rotation && node.rotation.jointId === jointId) {
                    node.rotation.angle = jointAngles[jointId];
                }
                if (node.children) {
                    node.children.forEach(updateNode);
                }
            };
            updateNode(rootNode);
        }

        document.querySelectorAll('#controls input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                updateJointAngle(e.target.dataset.jointId, parseFloat(e.target.value));
            });
            updateJointAngle(slider.dataset.jointId, parseFloat(slider.value));
        });

        canvas.addEventListener('mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mousemove', e => {
            if (!mouseDown) return;
            let dx = e.clientX - lastX;
            let dy = e.clientY - lastY;
            const rotationSpeed = 0.01;

            let instantaneousRotX = mat4RotateX(mat4Identity(), dy * rotationSpeed);
            let instantaneousRotY = mat4RotateY(mat4Identity(), dx * rotationSpeed);

            let newRotation = multiplyMat4(instantaneousRotY, instantaneousRotX);
            accumulatedRotationMatrix = multiplyMat4(newRotation, accumulatedRotationMatrix);

            lastX = e.clientX; 
            lastY = e.clientY;
        });

        document.addEventListener('keydown', e => {
            const step = 0.5;
            switch (e.key) {
                case 'ArrowUp': camY += step; break;
                case 'ArrowDown': camY -= step; break;
                case 'ArrowLeft': camX -= step; break;
                case 'ArrowRight': camX += step; break;
                case 'w': camZ += step; break;
                case 's': camZ -= step; break;
            }
        });
        
        requestAnimationFrame(render);
    }
  </script>
</body>

</html>
